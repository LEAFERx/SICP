# 练习1.5

**应用序** 解释器首先对运算符和各个运算对象进行求值，然后将得到的过程应用于得到的实际参数

**正则序** 直到实际需要值时才去求值 即解释器用运算对象表达式代换形式参数 直到得到一个只包含基本运算符的表达式再统一求值

```scheme
;Ben's code
(define (p) (p))

(define (test x y)
    (if (= x 0)
        0
        y))

(test 0 (p))
```

第一条语句定义了一个不需要参数的过程p 这个过程返回调用这个过程返回的值 很明显这是一个不能退出的递归定义（就像GNU: GNU is Not Unix一样XD） 所以对过程p求值将会导致解释器陷入无限循环

所以当解释器对第三条语句进行求值的时候

如果解释器采用应用序 那么代换模型就会变成这样：
```scheme
(test 0 (p))
```
代换为
```scheme
(test 0 (p))
```
代换为
```scheme
(test 0 (p))
```
......

(p)将一直被代换为(p)

于是解释器将**陷入死循环**

而如果解释器采用正则序 那么代换模型就会变成这样：
```scheme
(test 0 (p))
```
代换为
```scheme
(if (= 0 0) 0 (p))
```
代换为
```scheme
0
```
即解释器将**返回0**


